// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "ControlSS.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

ControlSS::ControlSS() : Subsystem("ControlSS") {
	//initialize all variables
	posNum = 0;
	defNum = 0;
	windowNum = 0;
	shooterPSI = 0.0;
	armPSI = 0.0;

	shooterUse = false;
	armUse = false;

	time = new Timer();
	time->Start();

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    leftFrontM = RobotMap::controlSSleftFrontM;
    leftRearM = RobotMap::controlSSleftRearM;
    rightFrontM = RobotMap::controlSSrightFrontM;
    rightRearM = RobotMap::controlSSrightRearM;
    robotDrive = RobotMap::controlSSRobotDrive;
    shooterGauge = RobotMap::controlSSshooterGauge;
    armGauge = RobotMap::controlSSarmGauge;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}

void ControlSS::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void ControlSS::drive(std::shared_ptr<Joystick> left, std::shared_ptr<Joystick> right){
	//sets the value of the motors on the left side
	leftFrontM->Set(left->GetY());
	leftRearM->Set(left->GetY());
	//sets the value of the motors on the right side
	rightFrontM->Set(right->GetY());
	rightRearM->Set(right->GetY());
}
void ControlSS::stop(){
	//sets to values of the motors to 0 to stop it
	leftFrontM->Set(0);
	leftRearM->Set(0);
	rightFrontM->Set(0);
	rightRearM->Set(0);
}

//position methods
void ControlSS::setPos1(){
	posNum = 1;
}
void ControlSS::setPos2(){
	posNum = 2;
}
void ControlSS::setPos3(){
	posNum = 3;
}
void ControlSS::setPos4(){
	posNum = 4;
}
void ControlSS::setPos5(){
	posNum = 5;
}

//defense methods
void ControlSS::setDef1(){
	defNum = 1;
}
void ControlSS::setDef2(){
	defNum = 2;
}
void ControlSS::setDef3(){
	defNum = 3;
}
void ControlSS::setDef4(){
	defNum = 4;
}
void ControlSS::setDef5(){
	defNum = 5;
}
void ControlSS::setDef6(){
	defNum = 6;
}
void ControlSS::setDef7(){
	defNum = 7;
}
void ControlSS::setDef8(){
	defNum = 8;
}
void ControlSS::setDef9(){
	defNum = 9;
}

//gauge methods
void ControlSS::updateShooter(){
	//gets the values from the shooter gauge
	shooterPSI = 0.255 * (shooterGauge->GetAverageValue()) - 25.427;

	//sets shooterUse to true if the PSI is over 100
	if (shooterPSI >= 100){
		shooterUse = true;
	}else{
		shooterUse = false;
	}
}
void ControlSS::updateArm(){
	//gets the values from the arm gauge
	armPSI = 0.255 * (armGauge->GetAverageValue()) - 25.427;

	//sets armUse to true if the PSI is over 100
	if (armPSI >= 100){
		armUse = true;
	}else{
		armUse = false;
	}
}

//methods to control window motor
/*void ControlSS::windowForward(){
	windowNum = windowMotor->Get();

	if (windowNum == 0){
		windowMotor->Set(Relay::Value::kOn);
		windowMotor->Set(Relay::Value::kForward);
	}else if (windowNum == -1){
		windowMotor->Set(Relay::Value::kForward);
	}
}
void ControlSS::windowReverse(){
	windowNum = windowMotor->Get();

	if (windowNum == 0){
		windowMotor->Set(Relay::Value::kOn);
		windowMotor->Set(Relay::Value::kReverse);
	}else if (windowNum == 1){
		windowMotor->Set(Relay::Value::kReverse);
	}
}
void ControlSS::windowStop(){
	windowMotor->Set(Relay::Value::kOff);
	windowNum = 0;
}
*/
